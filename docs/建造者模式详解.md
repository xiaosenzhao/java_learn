# Java 建造者模式详解

## 概述

建造者模式（Builder Pattern）是一种创建型设计模式，它允许您分步骤创建复杂对象。该模式将对象的构造过程与其表示分离，使得同样的构造过程可以创建不同的表示。

## 模式结构

### 核心组件

1. **产品（Product）** - 被构建的复杂对象
2. **抽象建造者（Builder）** - 定义创建产品各部分的接口
3. **具体建造者（ConcreteBuilder）** - 实现建造者接口，构造和装配产品的各个部分
4. **指挥者（Director）** - 使用建造者接口来构造对象

## 适用场景

### 何时使用建造者模式

1. **复杂对象创建** - 当对象有很多可选参数时
2. **不变对象** - 需要创建不可变对象时
3. **分步构建** - 需要分步骤创建对象时
4. **参数验证** - 需要在创建对象时进行复杂验证时

### 建造者模式的优点

- **可读性强** - 使用链式调用，代码易读
- **灵活性高** - 可以灵活控制构建过程
- **参数安全** - 避免了构造函数参数过多的问题
- **不变性** - 可以轻松创建不可变对象
- **验证集中** - 可以在build()方法中集中进行参数验证

### 建造者模式的缺点

- **代码量增加** - 需要额外的Builder类
- **复杂性** - 对于简单对象可能过度设计

## 实现方式

### 1. 静态内部类建造者（推荐）

```java
public class Computer {
    private final String cpu;
    private final String memory;
    private final String hardDisk;
    
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.hardDisk = builder.hardDisk;
    }
    
    public static class Builder {
        private final String cpu;
        private final String memory;
        private String hardDisk;
        
        public Builder(String cpu, String memory) {
            this.cpu = cpu;
            this.memory = memory;
        }
        
        public Builder hardDisk(String hardDisk) {
            this.hardDisk = hardDisk;
            return this;
        }
        
        public Computer build() {
            return new Computer(this);
        }
    }
}
```

**使用示例：**
```java
Computer computer = new Computer.Builder("Intel i7", "16GB")
        .hardDisk("512GB SSD")
        .build();
```

### 2. 传统建造者模式

```java
// 抽象建造者
public abstract class HouseBuilder {
    protected House house;
    
    public void createNewHouse() {
        house = new House();
    }
    
    public House getHouse() {
        return house;
    }
    
    public abstract void buildFoundation();
    public abstract void buildWalls();
    public abstract void buildRoof();
}

// 具体建造者
public class VillaBuilder extends HouseBuilder {
    @Override
    public void buildFoundation() {
        house.setFoundation("钢筋混凝土深基础");
    }
    
    @Override
    public void buildWalls() {
        house.setWalls("双层保温砖墙");
    }
    
    @Override
    public void buildRoof() {
        house.setRoof("欧式斜坡瓦屋顶");
    }
}

// 指挥者
public class HouseDirector {
    private HouseBuilder houseBuilder;
    
    public HouseDirector(HouseBuilder houseBuilder) {
        this.houseBuilder = houseBuilder;
    }
    
    public House constructHouse() {
        houseBuilder.createNewHouse();
        houseBuilder.buildFoundation();
        houseBuilder.buildWalls();
        houseBuilder.buildRoof();
        return houseBuilder.getHouse();
    }
}
```

### 3. 流畅的链式建造者

```java
public class Pizza {
    private final String size;
    private final String dough;
    private final List<String> toppings;
    
    private Pizza(Builder builder) {
        this.size = builder.size;
        this.dough = builder.dough;
        this.toppings = new ArrayList<>(builder.toppings);
    }
    
    public static class Builder {
        private final String size;
        private final String dough;
        private List<String> toppings = new ArrayList<>();
        
        public Builder(String size, String dough) {
            this.size = size;
            this.dough = dough;
        }
        
        public Builder addTopping(String topping) {
            this.toppings.add(topping);
            return this;
        }
        
        public Builder addToppings(String... toppings) {
            Collections.addAll(this.toppings, toppings);
            return this;
        }
        
        // 预设配置方法
        public Builder margherita() {
            this.toppings.clear();
            this.toppings.add("新鲜罗勒叶");
            return this;
        }
        
        public Pizza build() {
            return new Pizza(this);
        }
    }
}
```

### 4. Lombok @Builder 注解

```java
@Data
@Builder
public class Product {
    @NonNull
    private String name;
    
    @NonNull
    private String category;
    
    private BigDecimal price;
    private String description;
    
    @Singular
    private List<String> features;
    
    @Singular("addTag")
    private Set<String> tags;
}
```

**使用示例：**
```java
Product product = Product.builder()
        .name("MacBook Pro")
        .category("笔记本电脑")
        .price(new BigDecimal("15999.00"))
        .feature("M3 Pro芯片")
        .feature("Liquid Retina XDR显示屏")
        .addTag("高性能")
        .addTag("专业级")
        .build();
```

## 最佳实践

### 1. 参数验证

```java
public Computer build() {
    // 验证必需参数
    if (cpu == null || cpu.trim().isEmpty()) {
        throw new IllegalArgumentException("CPU不能为空");
    }
    if (memory == null || memory.trim().isEmpty()) {
        throw new IllegalArgumentException("内存不能为空");
    }
    
    return new Computer(this);
}
```

### 2. 不变性保证

```java
// 构造函数设为私有
private Computer(Builder builder) {
    this.cpu = builder.cpu;
    this.memory = builder.memory;
    // 对于集合类型，创建新的副本
    this.features = Collections.unmodifiableList(new ArrayList<>(builder.features));
}

// 只提供getter方法，不提供setter方法
public String getCpu() { return cpu; }
public String getMemory() { return memory; }
public List<String> getFeatures() { 
    return Collections.unmodifiableList(features); 
}
```

### 3. 预设配置方法

```java
public static class Builder {
    // 预设配置方法，提高易用性
    public Builder gamingConfig() {
        this.cpu = "Intel i9";
        this.memory = "32GB DDR4";
        this.graphicsCard = "RTX 4080";
        this.hardDisk = "1TB NVMe SSD";
        return this;
    }
    
    public Builder officeConfig() {
        this.cpu = "Intel i5";
        this.memory = "16GB DDR4";
        this.hardDisk = "512GB SSD";
        return this;
    }
}
```

### 4. 集合处理

```java
// 单个元素添加
public Builder addFeature(String feature) {
    if (this.features == null) {
        this.features = new ArrayList<>();
    }
    this.features.add(feature);
    return this;
}

// 批量添加
public Builder addFeatures(String... features) {
    if (this.features == null) {
        this.features = new ArrayList<>();
    }
    Collections.addAll(this.features, features);
    return this;
}

// 设置整个集合
public Builder features(List<String> features) {
    this.features = new ArrayList<>(features);
    return this;
}
```

## 与其他模式的比较

### Builder vs Factory

| 特性 | Builder模式 | Factory模式 |
|------|-------------|-------------|
| 复杂性 | 适合复杂对象 | 适合简单对象 |
| 参数数量 | 多个可选参数 | 少量参数 |
| 构建过程 | 分步骤构建 | 一步创建 |
| 灵活性 | 高度灵活 | 相对固定 |

### Builder vs Constructor

| 特性 | Builder模式 | 构造函数 |
|------|-------------|----------|
| 参数验证 | 集中在build()方法 | 分散在各个构造函数 |
| 可读性 | 高（链式调用） | 低（参数位置敏感） |
| 可选参数 | 易于处理 | 需要多个重载 |
| 不变性 | 容易实现 | 需要额外设计 |

## 实际应用场景

### 1. HTTP请求构建
```java
HttpRequest request = HttpRequest.builder()
        .url("https://api.example.com/users")
        .method(HttpMethod.POST)
        .header("Content-Type", "application/json")
        .header("Authorization", "Bearer token")
        .body(jsonBody)
        .timeout(Duration.ofSeconds(30))
        .build();
```

### 2. SQL查询构建
```java
String sql = SqlBuilder.select()
        .from("users")
        .where("age > ?", 18)
        .where("status = ?", "active")
        .orderBy("created_at DESC")
        .limit(10)
        .build();
```

### 3. 配置对象构建
```java
DatabaseConfig config = DatabaseConfig.builder()
        .host("localhost")
        .port(3306)
        .database("myapp")
        .username("user")
        .password("password")
        .maxConnections(20)
        .timeout(Duration.ofSeconds(30))
        .enableSSL()
        .build();
```

## 总结

建造者模式是一个非常实用的设计模式，特别适合创建复杂对象。它提供了良好的代码可读性和灵活性，是现代Java开发中广泛使用的模式。结合Lombok等工具，可以进一步减少样板代码，提高开发效率。

**选择建造者模式的经验法则：**
- 超过4个构造参数时考虑使用
- 需要创建不可变对象时
- 有很多可选参数时
- 需要分步骤构建对象时 