# ScopedValue 和 ThreadLocal 详解

## 概述

`ThreadLocal` 和 `ScopedValue` 都是 Java 中用于线程本地存储的机制，但它们在设计理念、性能和使用方式上有显著差异。

## ThreadLocal

### 基本概念
ThreadLocal 是 Java 1.2 引入的线程本地变量机制，为每个线程提供独立的变量副本。

### 特点
- **可变性**：可以随时 get/set 值
- **生命周期长**：直到线程结束或显式 remove()
- **内存管理**：需要手动清理避免内存泄漏
- **性能开销**：每次访问需要查找 ThreadLocalMap

### 常见问题
1. **内存泄漏**：忘记 remove() 导致对象无法回收
2. **性能问题**：频繁 get/set 操作有开销
3. **继承问题**：子线程无法继承父线程的值（需要 InheritableThreadLocal）

## ScopedValue (Java 19+)

### 基本概念
ScopedValue 是 Java 19 引入的现代化线程本地存储机制，提供了更好的性能和内存管理。

### 特点
- **不可变性**：一旦绑定，值在作用域内不可变
- **作用域限制**：只在特定代码块内有效
- **自动清理**：作用域结束自动清理，无内存泄漏
- **高性能**：优化的内存布局和访问机制
- **结构化并发友好**：天然支持结构化并发模式

### 优势
1. **更好的性能**：比 ThreadLocal 快 20-30%
2. **内存安全**：自动管理生命周期
3. **不可变性**：避免意外修改
4. **清晰的作用域**：代码更易理解和维护

## 对比分析

| 特性 | ThreadLocal | ScopedValue |
|------|-------------|-------------|
| **引入版本** | Java 1.2 | Java 19 (预览), Java 21 (正式) |
| **可变性** | 可变 (get/set) | 不可变 (只读) |
| **生命周期** | 手动管理 | 自动管理 |
| **内存泄漏风险** | 高 (需要 remove) | 低 (自动清理) |
| **性能** | 较低 | 较高 |
| **线程继承** | InheritableThreadLocal | 自动继承 |
| **作用域** | 全局 (线程级) | 局部 (代码块级) |

## 使用场景

### ThreadLocal 适用场景
- 需要在线程生命周期内多次修改值
- 兼容旧版本 Java (< 19)
- 传统的线程池模式

### ScopedValue 适用场景
- 值在作用域内保持不变
- 结构化并发编程
- 高性能要求的应用
- 现代 Java 应用 (19+)

## 最佳实践

### ThreadLocal 最佳实践
1. **必须清理**：使用完毕后调用 remove()
2. **try-finally 模式**：确保在 finally 块中清理
3. **避免大对象**：存储轻量级对象
4. **谨慎继承**：考虑是否需要 InheritableThreadLocal

### ScopedValue 最佳实践
1. **合理设计作用域**：不要让作用域过大
2. **值的不可变性**：利用不可变特性设计
3. **结构化并发**：结合 Virtual Thread 使用
4. **性能优化**：优先选择 ScopedValue

## 迁移建议

从 ThreadLocal 迁移到 ScopedValue：
1. **评估使用模式**：确认是否需要可变性
2. **重构作用域**：将全局访问改为作用域访问
3. **移除清理代码**：不再需要手动 remove()
4. **性能测试**：验证性能提升

## 总结

- **ThreadLocal**：成熟稳定，但需要小心内存管理
- **ScopedValue**：现代化解决方案，性能更好，更安全
- **选择建议**：新项目优先选择 ScopedValue，旧项目可考虑逐步迁移 